        -:    0:Source:../../../../../src/HCFS/utils.c
        -:    0:Graph:utils.gcno
        -:    0:Data:utils.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <semaphore.h>
        -:    4:#include <unistd.h>
        -:    5:#include <string.h>
        -:    6:#include <sys/stat.h>
        -:    7:#include <sys/types.h>
        -:    8:#include <attr/xattr.h>
        -:    9:
        -:   10:#include "utils.h"
        -:   11:#include "global.h"
        -:   12:#include "fuseop.h"
        -:   13:#include "params.h"
        -:   14:
        -:   15:SYSTEM_CONF_STRUCT system_config;
        -:   16:
        6:   17:int fetch_meta_path(char *pathname, ino_t this_inode)   /*Will copy the filename of the meta file to pathname*/
        -:   18: {
        -:   19:  char tempname[METAPATHLEN];
        -:   20:  int sub_dir;
        6:   21:  int ret_code=0;
        -:   22:
        6:   23:  if (METAPATH == NULL)
        1:   24:   return -1;
        -:   25:
        5:   26:  if (access(METAPATH,F_OK)==-1)
        -:   27:   {
        3:   28:    ret_code = mkdir(METAPATH,0700);
        3:   29:    if (ret_code < 0)
        1:   30:     return ret_code;
        -:   31:   }
        -:   32:
        4:   33:  sub_dir = this_inode % NUMSUBDIR;
        4:   34:  sprintf(tempname,"%s/sub_%d",METAPATH,sub_dir);
        4:   35:  if (access(tempname,F_OK)==-1)
        -:   36:   {
        4:   37:    ret_code = mkdir(tempname,0700);
        -:   38:
        4:   39:    if (ret_code < 0)
        1:   40:     return ret_code;
        -:   41:   }
        -:   42:
        3:   43:  sprintf(tempname,"%s/sub_%d/meta%lld",METAPATH,sub_dir,this_inode);
        3:   44:  strcpy(pathname,tempname);
        -:   45:
        3:   46:  ret_code = 0;
        3:   47:  return ret_code;
        -:   48: }
    #####:   49:int fetch_todelete_path(char *pathname, ino_t this_inode)   /*Will copy the filename of the meta file in todelete folder to pathname*/
        -:   50: {
        -:   51:  char tempname[400];
        -:   52:  int sub_dir;
        -:   53:
    #####:   54:  sub_dir = this_inode % NUMSUBDIR;
    #####:   55:  sprintf(tempname,"%s/todelete",METAPATH);
    #####:   56:  if (access(tempname,F_OK)==-1)
    #####:   57:   mkdir(tempname,0700);
    #####:   58:  sprintf(tempname,"%s/todelete/sub_%d",METAPATH,sub_dir);
    #####:   59:  if (access(tempname,F_OK)==-1)
    #####:   60:   mkdir(tempname,0700);
    #####:   61:  sprintf(tempname,"%s/todelete/sub_%d/meta%lld",METAPATH,sub_dir,this_inode);
    #####:   62:  strcpy(pathname,tempname);
    #####:   63:  return 0;
        -:   64: }
    #####:   65:int fetch_block_path(char *pathname, ino_t this_inode, long long block_num)   /*Will copy the filename of the block file to pathname*/
        -:   66: {
        -:   67:  char tempname[400];
        -:   68:  int sub_dir;
        -:   69:
    #####:   70:  sub_dir = (this_inode + block_num) % NUMSUBDIR;
    #####:   71:  sprintf(tempname,"%s/sub_%d",BLOCKPATH,sub_dir);
    #####:   72:  if (access(tempname,F_OK)==-1)
    #####:   73:   mkdir(tempname,0700);
    #####:   74:  sprintf(tempname,"%s/sub_%d/block%lld_%lld",BLOCKPATH,sub_dir,this_inode,block_num);
    #####:   75:  strcpy(pathname,tempname);
    #####:   76:  return 0;
        -:   77: }
        -:   78:
    #####:   79:int parse_parent_self(const char *pathname, char *parentname, char *selfname)
        -:   80: {
        -:   81:  int count;
        -:   82:
    #####:   83:  for(count = strlen(pathname)-1;count>=0;count--)
        -:   84:   {
    #####:   85:    if ((pathname[count]=='/') && (count < (strlen(pathname)-1)))
    #####:   86:     break;
        -:   87:   }
    #####:   88:  if (count ==0)
        -:   89:   {
    #####:   90:    strcpy(parentname,"/");
    #####:   91:    strcpy(selfname,&(pathname[1]));
        -:   92:   }
        -:   93:  else
        -:   94:   {
    #####:   95:    strncpy(parentname,pathname,count);
    #####:   96:    parentname[count]=0;
    #####:   97:    strcpy(selfname,&(pathname[count+1]));
        -:   98:   }
    #####:   99:  return 0;
        -:  100: }
        -:  101:
    #####:  102:int read_system_config(char *config_path)
        -:  103: {
        -:  104:  FILE *fptr;
        -:  105:  char tempbuf[200],*ret_ptr;
        -:  106:  char argname[200],argval[200],*tokptr1,*tokptr2, *toktmp, *strptr;
        -:  107:
    #####:  108:  fptr=fopen(config_path,"r");
        -:  109:
    #####:  110:  if (fptr==NULL)
        -:  111:   {
    #####:  112:    printf("Cannot open config file (%s) for reading\n",config_path);
    #####:  113:    exit(-1);
        -:  114:   }
        -:  115:
    #####:  116:  while(!feof(fptr))
        -:  117:   {
    #####:  118:    ret_ptr = fgets(tempbuf,180,fptr);
    #####:  119:    if (ret_ptr == NULL)
    #####:  120:     break;
        -:  121:    
    #####:  122:    if (strlen(tempbuf) > 170)
        -:  123:     {
    #####:  124:      printf("Length of option value exceeds limit (170 chars). Exiting.\n");
    #####:  125:      exit(-1);
        -:  126:     }
    #####:  127:    if (tempbuf[strlen(tempbuf)-1]=='\n')
    #####:  128:     tempbuf[strlen(tempbuf)-1]=0;
        -:  129:
        -:  130:    /*Now decompose the option line into param name and value*/
        -:  131:    
    #####:  132:    toktmp=strtok_r(tempbuf,"=",&tokptr1);
        -:  133:
    #####:  134:    if (toktmp==NULL)
    #####:  135:     continue;
        -:  136:
        -:  137:    /*Get rid of the leading and trailing space chars*/
        -:  138:
    #####:  139:    strptr=toktmp;
    #####:  140:    while(*strptr==' ')
    #####:  141:     strptr=strptr+sizeof(char);
        -:  142:
    #####:  143:    strcpy(argname,strptr);
    #####:  144:    while(argname[strlen(argname)-1]==' ')
    #####:  145:     argname[strlen(argname)-1]=0;
        -:  146:
        -:  147:    /*Continue with the param value*/
    #####:  148:    toktmp=strtok_r(NULL,"=",&tokptr1);
    #####:  149:    if (toktmp==NULL)
    #####:  150:     continue;
        -:  151:
    #####:  152:    strptr=toktmp;
    #####:  153:    while(*strptr==' ')
    #####:  154:     strptr=strptr+sizeof(char);
    #####:  155:    strcpy(argval,strptr);
    #####:  156:    while(argval[strlen(argval)-1]==' ')
    #####:  157:     argval[strlen(argval)-1]=0;
        -:  158:
        -:  159:    /*Match param name with required params*/
    #####:  160:    if (strcasecmp(argname,"metapath")==0)
        -:  161:     {
    #####:  162:      METAPATH= (char *) malloc(strlen(argval)+10);
    #####:  163:      strcpy(METAPATH,argval);
    #####:  164:      continue;
        -:  165:     }
    #####:  166:    if (strcasecmp(argname,"blockpath")==0)
        -:  167:     {
    #####:  168:      BLOCKPATH= (char *) malloc(strlen(argval)+10);
    #####:  169:      strcpy(BLOCKPATH,argval);
    #####:  170:      continue;
        -:  171:     }
    #####:  172:    if (strcasecmp(argname,"superblock")==0)
        -:  173:     {
    #####:  174:      SUPERBLOCK= (char *) malloc(strlen(argval)+10);
    #####:  175:      strcpy(SUPERBLOCK,argval);
    #####:  176:      continue;
        -:  177:     }
    #####:  178:    if (strcasecmp(argname,"unclaimedfile")==0)
        -:  179:     {
    #####:  180:      UNCLAIMEDFILE= (char *) malloc(strlen(argval)+10);
    #####:  181:      strcpy(UNCLAIMEDFILE,argval);
    #####:  182:      continue;
        -:  183:     }
    #####:  184:    if (strcasecmp(argname,"hcfssystem")==0)
        -:  185:     {
    #####:  186:      HCFSSYSTEM= (char *) malloc(strlen(argval)+10);
    #####:  187:      strcpy(HCFSSYSTEM,argval);
    #####:  188:      continue;
        -:  189:     }
    #####:  190:    if (strcasecmp(argname,"cache_soft_limit")==0)
        -:  191:     {
    #####:  192:      CACHE_SOFT_LIMIT=atoll(argval);
    #####:  193:      continue;
        -:  194:     }
    #####:  195:    if (strcasecmp(argname,"cache_hard_limit")==0)
        -:  196:     {
    #####:  197:      CACHE_HARD_LIMIT=atoll(argval);
    #####:  198:      continue;
        -:  199:     }
    #####:  200:    if (strcasecmp(argname,"cache_delta")==0)
        -:  201:     {
    #####:  202:      CACHE_DELTA=atoll(argval);
    #####:  203:      continue;
        -:  204:     }
    #####:  205:    if (strcasecmp(argname,"max_block_size")==0)
        -:  206:     {
    #####:  207:      MAX_BLOCK_SIZE=atoll(argval);
    #####:  208:      continue;
        -:  209:     }
        -:  210:    
        -:  211:   }
    #####:  212:  fclose(fptr);
        -:  213:  
    #####:  214:  return 0;
        -:  215: }
        -:  216:
    #####:  217:int validate_system_config()
        -:  218: {
        -:  219:  FILE *fptr;
        -:  220:  char pathname[400];
        -:  221:  char tempval[10];
        -:  222:  int ret_val;
        -:  223:
    #####:  224:  printf("%s 1\n%s 2\n%s 3\n%s 4\n%s 5\n", METAPATH,BLOCKPATH, SUPERBLOCK, UNCLAIMEDFILE, HCFSSYSTEM);
    #####:  225:  printf("%lld %lld %lld %lld\n", CACHE_SOFT_LIMIT, CACHE_HARD_LIMIT, CACHE_DELTA, MAX_BLOCK_SIZE);
        -:  226:
    #####:  227:  sprintf(pathname,"%s/testfile",BLOCKPATH);
        -:  228:
    #####:  229:  fptr=fopen(pathname,"w");
    #####:  230:  fprintf(fptr,"test\n");
    #####:  231:  fclose(fptr);
        -:  232:
    #####:  233:  ret_val = setxattr(pathname,"user.dirty","T",1,0);
    #####:  234:  if (ret_val < 0)
        -:  235:   {
    #####:  236:    printf("Needs support for extended attributes, error no: %d\n",errno);
    #####:  237:    exit(-1);
        -:  238:   }
        -:  239:
    #####:  240:  tempval[0]=0;
    #####:  241:  getxattr(pathname,"user.dirty",(void *)tempval,1);
    #####:  242:  printf("test value is: %s, %d\n",tempval,strncmp(tempval,"T",1));
    #####:  243:  unlink(pathname);
        -:  244:
        -:  245:
        -:  246:
    #####:  247:  return 0;
        -:  248: }
        -:  249:
        -:  250:
        -:  251:
        2:  252:off_t check_file_size(const char *path)
        -:  253: {
        -:  254:  struct stat block_stat;
        -:  255:
        2:  256:  if (stat(path,&block_stat)==0)
        1:  257:   return block_stat.st_size;
        -:  258:  else
        1:  259:   return -1;
        -:  260: }
        -:  261:
        -:  262:
